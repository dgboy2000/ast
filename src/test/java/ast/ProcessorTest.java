package ast;

import com.sun.source.tree.Tree;
import com.sun.tools.javac.tree.JCTree;
import com.sun.tools.javac.util.Name;

import javax.lang.model.element.Modifier;
import java.util.ArrayList;
import java.util.List;

/**
 * Created with IntelliJ IDEA.
 * User: dannygoodman
 * Date: 6/7/14
 * Time: 2:09 PM
 * To change this template use File | Settings | File Templates.
 */
public class ProcessorTest {

    // Autogenerated code:
//    public static class MinifiedProcessor extends JCTree.Visitor{private int indentLevel=0;private List<String>nestedClasses=new ArrayList<String>();private String getCurrentClass(){return nestedClasses.get(nestedClasses.size()-1);}private void print(Object toPrint){StringBuilder indentBuilder=new StringBuilder();for(int i=0;i<indentLevel;++i)indentBuilder.append("\t");System.out.print(toPrint.toString().replaceAll("\n","\n"+indentBuilder.toString()));}public void visitApply(JCTree.JCMethodInvocation jcMethodInvocation){visitTree(jcMethodInvocation.getMethodSelect());print("(");List<JCTree.JCExpression>arguments=jcMethodInvocation.getArguments();if(arguments.size()>0){visitTree(arguments.get(0));for(JCTree.JCExpression arg:arguments.subList(1,arguments.size())){print(", ");visitTree(arg);}}print(")");}public void visitAssign(JCTree.JCAssign jcAssign){visitTree(jcAssign.getVariable());print(" = ");visitTree(jcAssign.getExpression());print(";");}public void visitBinary(JCTree.JCBinary jcBinary){visitTree(jcBinary.getLeftOperand());print(" ");visitOperator(jcBinary.getKind());print(" ");visitTree(jcBinary.getRightOperand());}public void visitBlock(JCTree.JCBlock jcBlock){print("\n{");++indentLevel;for(JCTree.JCStatement jcStatement:jcBlock.getStatements()){print("\n");visitTree(jcStatement);}--indentLevel;print("\n}");}public void visitBreak(JCTree.JCBreak jcBreak){print("break;");}public void visitCase(JCTree.JCCase jcCase){print("\n");if(jcCase.getExpression()==null){print("default");}else{print("case ");visitTree(jcCase.getExpression());}print(":");++indentLevel;for(JCTree.JCStatement statement:jcCase.getStatements()){print("\n");visitTree(statement);}--indentLevel;}public void visitCatch(JCTree.JCCatch jcCatch){print("\ncatch (");visitVarDef(jcCatch.getParameter());print(")");visitBlock(jcCatch.getBlock());}public void visitClassDef(JCTree.JCClassDecl jcClassDecl){print("\n\n");visitModifiers(jcClassDecl.getModifiers());print("class "+jcClassDecl.getSimpleName());if(jcClassDecl.getExtendsClause()!=null){print(" extends ");visitTree(jcClassDecl.getExtendsClause());}List<JCTree.JCExpression>interfaces=jcClassDecl.getImplementsClause();if(interfaces.size()>0){print(" implements ");visitTree(interfaces.get(0));for(JCTree.JCExpression jcExpression:interfaces.subList(1,interfaces.size())){print(", ");visitTree(jcExpression);}}nestedClasses.add(jcClassDecl.getSimpleName().toString());visitClassMembers(jcClassDecl.getMembers());nestedClasses.remove(nestedClasses.size()-1);}private void visitClassMembers(List<JCTree>members){print("\n{");++indentLevel;for(JCTree member:members){print("\n");visitTree(member);}--indentLevel;print("\n}\n");}public void visitExec(JCTree.JCExpressionStatement jcExpressionStatement){visitTree(jcExpressionStatement.getExpression());print(";");}public void visitForeachLoop(JCTree.JCEnhancedForLoop jcEnhancedForLoop){print("for (");visitVarDef(jcEnhancedForLoop.getVariable());print(" : ");visitTree(jcEnhancedForLoop.getExpression());print(") ");visitTree(jcEnhancedForLoop.getStatement());}public void visitForLoop(JCTree.JCForLoop jcForLoop){print("for (");List<JCTree.JCStatement>initializers=jcForLoop.getInitializer();if(initializers.size()==1){visitTree(initializers.get(0));}else if(initializers.size()>1)throw new IllegalArgumentException("Too many initializers: "+initializers.size());print(" ");visitTree(jcForLoop.getCondition());print("; ");List<JCTree.JCExpressionStatement>updates=jcForLoop.getUpdate();if(updates.size()==1){visitTree(updates.get(0).getExpression());}else if(initializers.size()>1)throw new IllegalArgumentException("Too many initializers: "+initializers.size());print(") ");visitTree(jcForLoop.getStatement());}public void visitIdent(JCTree.JCIdent jcIdent){print(jcIdent.getName());}public void visitIf(JCTree.JCIf jcIf){print("if ");visitTree(jcIf.getCondition());print(" ");visitTree(jcIf.getThenStatement());if(jcIf.getElseStatement()!=null){print("\nelse ");visitTree(jcIf.getElseStatement());}}public void visitImport(JCTree.JCImport jcImport){print("\n");if(jcImport.isStatic())System.out.print("static ");print("import ");visitTree(jcImport.getQualifiedIdentifier());print(";");}public void visitLiteral(JCTree.JCLiteral jcLiteral){print(jcLiteral.toString());}public void visitMethodDef(JCTree.JCMethodDecl jcMethodDecl){print("\n");visitModifiers(jcMethodDecl.getModifiers());if(jcMethodDecl.getReturnType()!=null){visitTree(jcMethodDecl.getReturnType());print(" ");}if(jcMethodDecl.getName().toString().equals("<init>"))print(getCurrentClass());else print(jcMethodDecl.getName());print("(");List<JCTree.JCVariableDecl>parameters=jcMethodDecl.getParameters();if(parameters.size()>0){visitVarDef(parameters.get(0));for(JCTree.JCVariableDecl param:parameters.subList(1,parameters.size())){print(", ");visitVarDef(param);}}print(")");List<JCTree.JCExpression>possibleExceptions=jcMethodDecl.getThrows();if(possibleExceptions.size()>0){print(" throws ");visitTree(possibleExceptions.get(0));for(JCTree.JCExpression exception:possibleExceptions.subList(1,possibleExceptions.size())){print(", ");visitTree(exception);}}visitBlock(jcMethodDecl.getBody());}public void visitModifiers(JCTree.JCModifiers jcModifiers){for(Modifier modifier:jcModifiers.getFlags()){print(modifier.toString()+" ");}}public void visitNewClass(JCTree.JCNewClass jcNewClass){print("new "+jcNewClass.getIdentifier()+"(");List<JCTree.JCExpression>arguments=jcNewClass.getArguments();if(arguments.size()>0){visitTree(arguments.get(0));for(JCTree.JCExpression arg:arguments.subList(1,arguments.size())){print(", ");visitTree(arg);}}print(")");if(jcNewClass.getClassBody()!=null){visitClassMembers(jcNewClass.getClassBody().getMembers());}}private void visitOperator(Tree.Kind kind){switch(kind){case PLUS:print("+");break;case MINUS:print("-");break;case MULTIPLY:print("*");break;case DIVIDE:print("/");break;case REMAINDER:print("%");break;case LESS_THAN:print("<");break;case GREATER_THAN:print(">");break;case LESS_THAN_EQUAL:print("<=");break;case GREATER_THAN_EQUAL:print(">=");break;case EQUAL_TO:print("==");break;case NOT_EQUAL_TO:print("!=");break;case AND:print("&&");break;case OR:print("||");break;case MULTIPLY_ASSIGNMENT:print("*=");break;case DIVIDE_ASSIGNMENT:print("/=");break;case REMAINDER_ASSIGNMENT:print("%=");break;case PLUS_ASSIGNMENT:print("+=");break;case MINUS_ASSIGNMENT:print("-=");break;case PREFIX_INCREMENT:print("++");break;case PREFIX_DECREMENT:print("--");break;default:throw new IllegalArgumentException("Unrecognized operator "+kind.toString());}}public void visitParens(JCTree.JCParens jcParens){print("(");visitTree(jcParens.getExpression());print(")");}public void visitReturn(JCTree.JCReturn jcReturn){print("\nreturn ");visitTree(jcReturn.getExpression());print(";");}public void visitSelect(JCTree.JCFieldAccess jcFieldAccess){visitTree(jcFieldAccess.selected);print("."+jcFieldAccess.getIdentifier());}public void visitSwitch(JCTree.JCSwitch jcSwitch){print("switch ");visitTree(jcSwitch.getExpression());print("\n{");++indentLevel;for(JCTree.JCCase jcCase:jcSwitch.getCases()){visitCase(jcCase);}--indentLevel;print("\n}");}public void visitThrow(JCTree.JCThrow jcThrow){print("throw ");visitTree(jcThrow.getExpression());print(";");}public void visitTopLevel(JCTree.JCCompilationUnit compilationUnit){print("package "+compilationUnit.getPackageName()+";\n");for(JCTree.JCImport jcImport:compilationUnit.getImports()){visitImport(jcImport);}for(JCTree jcTree:compilationUnit.getTypeDecls()){visitTree(jcTree);}}public void visitTree(JCTree jcTree){if(jcTree==null)return;switch(jcTree.getKind()){case ASSIGNMENT:this.visitAssign((JCTree.JCAssign)jcTree);break;case ARRAY_TYPE:this.visitTypeArray((JCTree.JCArrayTypeTree)jcTree);break;case BLOCK:this.visitBlock((JCTree.JCBlock)jcTree);break;case BREAK:this.visitBreak((JCTree.JCBreak)jcTree);break;case CLASS:this.visitClassDef((JCTree.JCClassDecl)jcTree);break;case ENHANCED_FOR_LOOP:this.visitForeachLoop((JCTree.JCEnhancedForLoop)jcTree);break;case EMPTY_STATEMENT:break;case EXPRESSION_STATEMENT:this.visitExec((JCTree.JCExpressionStatement)jcTree);break;case FOR_LOOP:this.visitForLoop((JCTree.JCForLoop)jcTree);break;case IDENTIFIER:this.visitIdent((JCTree.JCIdent)jcTree);break;case IF:this.visitIf((JCTree.JCIf)jcTree);break;case INSTANCE_OF:this.visitTypeTest((JCTree.JCInstanceOf)jcTree);break;case MEMBER_SELECT:this.visitSelect((JCTree.JCFieldAccess)jcTree);break;case METHOD:this.visitMethodDef((JCTree.JCMethodDecl)jcTree);break;case METHOD_INVOCATION:this.visitApply((JCTree.JCMethodInvocation)jcTree);break;case MODIFIERS:this.visitModifiers((JCTree.JCModifiers)jcTree);break;case NEW_CLASS:this.visitNewClass((JCTree.JCNewClass)jcTree);break;case PARAMETERIZED_TYPE:this.visitTypeApply((JCTree.JCTypeApply)jcTree);break;case PARENTHESIZED:this.visitParens((JCTree.JCParens)jcTree);break;case PRIMITIVE_TYPE:this.visitTypeIdent((JCTree.JCPrimitiveTypeTree)jcTree);break;case RETURN:this.visitReturn((JCTree.JCReturn)jcTree);break;case SWITCH:this.visitSwitch((JCTree.JCSwitch)jcTree);break;case THROW:this.visitThrow((JCTree.JCThrow)jcTree);break;case TRY:this.visitTry((JCTree.JCTry)jcTree);break;case TYPE_CAST:this.visitTypeCast((JCTree.JCTypeCast)jcTree);break;case VARIABLE:this.visitVarDef((JCTree.JCVariableDecl)jcTree);break;case PLUS:case MINUS:case MULTIPLY:case DIVIDE:case REMAINDER:case LESS_THAN:case GREATER_THAN:case LESS_THAN_EQUAL:case GREATER_THAN_EQUAL:case EQUAL_TO:case NOT_EQUAL_TO:case AND:case XOR:case OR:case CONDITIONAL_AND:case CONDITIONAL_OR:case MULTIPLY_ASSIGNMENT:case DIVIDE_ASSIGNMENT:case REMAINDER_ASSIGNMENT:case PLUS_ASSIGNMENT:case MINUS_ASSIGNMENT:case LEFT_SHIFT_ASSIGNMENT:case RIGHT_SHIFT_ASSIGNMENT:case UNSIGNED_RIGHT_SHIFT_ASSIGNMENT:case AND_ASSIGNMENT:case XOR_ASSIGNMENT:case OR_ASSIGNMENT:this.visitBinary((JCTree.JCBinary)jcTree);break;case INT_LITERAL:case LONG_LITERAL:case FLOAT_LITERAL:case DOUBLE_LITERAL:case BOOLEAN_LITERAL:case CHAR_LITERAL:case STRING_LITERAL:case NULL_LITERAL:this.visitLiteral((JCTree.JCLiteral)jcTree);break;case PREFIX_INCREMENT:case PREFIX_DECREMENT:this.visitUnary((JCTree.JCUnary)jcTree);break;default:throw new IllegalArgumentException("Unhandled kind "+jcTree.getKind().toString());}}public void visitTry(JCTree.JCTry jcTry){print("\ntry");visitBlock(jcTry.getBlock());for(JCTree.JCCatch jcCatch:jcTry.getCatches()){visitCatch(jcCatch);}if(jcTry.getFinallyBlock()!=null){print("\nfinally");visitBlock(jcTry.getFinallyBlock());}}public void visitTypeApply(JCTree.JCTypeApply jcTypeApply){visitTree(jcTypeApply.getType());print("<");List<JCTree.JCExpression>typeArguments=jcTypeApply.getTypeArguments();visitTree(typeArguments.get(0));for(JCTree.JCExpression jcExpression:typeArguments.subList(1,typeArguments.size())){print(", ");visitTree(jcExpression);}print(">");}public void visitTypeArray(JCTree.JCArrayTypeTree jcArrayTypeTree){visitTree(jcArrayTypeTree.getType());print("[]");}public void visitTypeCast(JCTree.JCTypeCast jcTypeCast){print("(");visitTree(jcTypeCast.getType());print(") ");visitTree(jcTypeCast.getExpression());}public void visitTypeIdent(JCTree.JCPrimitiveTypeTree jcPrimitiveTypeTree){print(jcPrimitiveTypeTree.getPrimitiveTypeKind());}public void visitTypeTest(JCTree.JCInstanceOf jcInstanceOf){visitTree(jcInstanceOf.getExpression());print(" instanceof ");visitTree(jcInstanceOf.getType());}public void visitUnary(JCTree.JCUnary jcUnary){visitOperator(jcUnary.getKind());visitTree(jcUnary.getExpression());}public void visitVarDef(JCTree.JCVariableDecl jcVariableDecl){visitModifiers(jcVariableDecl.getModifiers());visitTree(jcVariableDecl.vartype);print(" "+jcVariableDecl.getName());if(jcVariableDecl.getInitializer()!=null){print(" = ");visitTree(jcVariableDecl.getInitializer());print(";");}}}
    public static class MinifiedProcessor extends JCTree.Visitor{public static class Processor{private int indentLevel=0;private List<Name>nestedClasses=new ArrayList<Name>();public Name getCurrentClass(){return nestedClasses.get(nestedClasses.size()-1);}private boolean lastIsKeyword=false;private void printSym(Object toPrint){System.out.print(toPrint.toString());lastIsKeyword=false;;}private void printWord(Object toPrint){if(lastIsKeyword)System.out.print(" ");System.out.print(toPrint.toString());lastIsKeyword=true;;}public void processCloseBlock(){printSym("}");}public void processCloseClass(){this.nestedClasses.remove(this.nestedClasses.size()-1);}public void processCloseParenthesis(){printSym(")");}public void processKeyword(String keyword){printWord(keyword);}public void processLiteral(String literal){printWord(literal);}public void processName(Name name){printWord(name);}public void processOpenBlock(){printSym("{");}public void processOpenClass(Name className){this.nestedClasses.add(className);}public void processOpenParenthesis(){printSym("(");}public void processSymbol(String symbol){printSym(symbol);}}private Processor processor=new Processor();public void visitApply(JCTree.JCMethodInvocation jcMethodInvocation){visitTree(jcMethodInvocation.getMethodSelect());processor.processOpenParenthesis();List<JCTree.JCExpression>arguments=jcMethodInvocation.getArguments();if(arguments.size()>0){visitTree(arguments.get(0));for(JCTree.JCExpression arg:arguments.subList(1,arguments.size())){processor.processSymbol(",");visitTree(arg);}}processor.processCloseParenthesis();}public void visitAssign(JCTree.JCAssign jcAssign){visitTree(jcAssign.getVariable());processor.processSymbol("=");visitTree(jcAssign.getExpression());processor.processSymbol(";");}public void visitBinary(JCTree.JCBinary jcBinary){visitTree(jcBinary.getLeftOperand());visitOperator(jcBinary.getKind());visitTree(jcBinary.getRightOperand());}public void visitBlock(JCTree.JCBlock jcBlock){processor.processOpenBlock();for(JCTree.JCStatement jcStatement:jcBlock.getStatements()){visitTree(jcStatement);}processor.processCloseBlock();}public void visitBreak(JCTree.JCBreak jcBreak){processor.processKeyword("break");processor.processSymbol(";");}public void visitCase(JCTree.JCCase jcCase){if(jcCase.getExpression()==null){processor.processKeyword("default");}else{processor.processKeyword("case");visitTree(jcCase.getExpression());}processor.processSymbol(":");for(JCTree.JCStatement statement:jcCase.getStatements()){visitTree(statement);}}public void visitCatch(JCTree.JCCatch jcCatch){processor.processKeyword("catch");processor.processOpenParenthesis();visitVarDef(jcCatch.getParameter());processor.processCloseParenthesis();visitBlock(jcCatch.getBlock());}public void visitClassDef(JCTree.JCClassDecl jcClassDecl){visitModifiers(jcClassDecl.getModifiers());processor.processKeyword("class");processor.processName(jcClassDecl.getSimpleName());if(jcClassDecl.getExtendsClause()!=null){processor.processKeyword("extends");visitTree(jcClassDecl.getExtendsClause());}List<JCTree.JCExpression>interfaces=jcClassDecl.getImplementsClause();if(interfaces.size()>0){processor.processKeyword("implements");visitTree(interfaces.get(0));for(JCTree.JCExpression jcExpression:interfaces.subList(1,interfaces.size())){processor.processSymbol(",");visitTree(jcExpression);}}processor.processOpenClass(jcClassDecl.getSimpleName());visitClassMembers(jcClassDecl.getMembers());processor.processCloseClass();}private void visitClassMembers(List<JCTree>members){processor.processOpenBlock();for(JCTree member:members){visitTree(member);}processor.processCloseBlock();}public void visitExec(JCTree.JCExpressionStatement jcExpressionStatement){visitTree(jcExpressionStatement.getExpression());processor.processSymbol(";");}public void visitForeachLoop(JCTree.JCEnhancedForLoop jcEnhancedForLoop){processor.processKeyword("for");processor.processOpenParenthesis();visitVarDef(jcEnhancedForLoop.getVariable());processor.processSymbol(":");visitTree(jcEnhancedForLoop.getExpression());processor.processCloseParenthesis();visitTree(jcEnhancedForLoop.getStatement());}public void visitForLoop(JCTree.JCForLoop jcForLoop){processor.processKeyword("for");processor.processOpenParenthesis();List<JCTree.JCStatement>initializers=jcForLoop.getInitializer();if(initializers.size()==1){visitTree(initializers.get(0));}else if(initializers.size()>1)throw new IllegalArgumentException("Too many initializers: "+initializers.size());visitTree(jcForLoop.getCondition());processor.processSymbol(";");List<JCTree.JCExpressionStatement>updates=jcForLoop.getUpdate();if(updates.size()==1){visitTree(updates.get(0).getExpression());}else if(initializers.size()>1)throw new IllegalArgumentException("Too many initializers: "+initializers.size());processor.processCloseParenthesis();visitTree(jcForLoop.getStatement());}public void visitIdent(JCTree.JCIdent jcIdent){processor.processName(jcIdent.getName());}public void visitIf(JCTree.JCIf jcIf){processor.processKeyword("if");visitTree(jcIf.getCondition());visitTree(jcIf.getThenStatement());if(jcIf.getElseStatement()!=null){processor.processKeyword("else");visitTree(jcIf.getElseStatement());}}public void visitImport(JCTree.JCImport jcImport){if(jcImport.isStatic()){processor.processKeyword("static");}processor.processKeyword("import");visitTree(jcImport.getQualifiedIdentifier());processor.processSymbol(";");}public void visitLiteral(JCTree.JCLiteral jcLiteral){processor.processLiteral(jcLiteral.toString());}public void visitMethodDef(JCTree.JCMethodDecl jcMethodDecl){visitModifiers(jcMethodDecl.getModifiers());if(jcMethodDecl.getReturnType()!=null){visitTree(jcMethodDecl.getReturnType());}if(jcMethodDecl.getName().toString().equals("<init>"))processor.processName(processor.getCurrentClass());else processor.processName(jcMethodDecl.getName());processor.processOpenParenthesis();List<JCTree.JCVariableDecl>parameters=jcMethodDecl.getParameters();if(parameters.size()>0){visitVarDef(parameters.get(0));for(JCTree.JCVariableDecl param:parameters.subList(1,parameters.size())){processor.processSymbol(",");visitVarDef(param);}}processor.processCloseParenthesis();List<JCTree.JCExpression>possibleExceptions=jcMethodDecl.getThrows();if(possibleExceptions.size()>0){processor.processKeyword("throws");visitTree(possibleExceptions.get(0));for(JCTree.JCExpression exception:possibleExceptions.subList(1,possibleExceptions.size())){processor.processSymbol(",");visitTree(exception);}}visitBlock(jcMethodDecl.getBody());}public void visitModifiers(JCTree.JCModifiers jcModifiers){for(Modifier modifier:jcModifiers.getFlags()){processor.processKeyword(modifier.toString());}}public void visitNewClass(JCTree.JCNewClass jcNewClass){processor.processKeyword("new");visitTree(jcNewClass.getIdentifier());processor.processOpenParenthesis();List<JCTree.JCExpression>arguments=jcNewClass.getArguments();if(arguments.size()>0){visitTree(arguments.get(0));for(JCTree.JCExpression arg:arguments.subList(1,arguments.size())){processor.processSymbol(",");visitTree(arg);}}processor.processCloseParenthesis();if(jcNewClass.getClassBody()!=null){visitClassMembers(jcNewClass.getClassBody().getMembers());}}private void visitOperator(Tree.Kind kind){switch(kind){case PLUS:processor.processSymbol("+");break;case MINUS:processor.processSymbol("-");break;case MULTIPLY:processor.processSymbol("*");break;case DIVIDE:processor.processSymbol("/");break;case REMAINDER:processor.processSymbol("%");break;case LESS_THAN:processor.processSymbol("<");break;case GREATER_THAN:processor.processSymbol(">");break;case LESS_THAN_EQUAL:processor.processSymbol("<=");break;case GREATER_THAN_EQUAL:processor.processSymbol(">=");break;case EQUAL_TO:processor.processSymbol("==");break;case NOT_EQUAL_TO:processor.processSymbol("!=");break;case AND:processor.processSymbol("&&");break;case OR:processor.processSymbol("||");break;case MULTIPLY_ASSIGNMENT:processor.processSymbol("*=");break;case DIVIDE_ASSIGNMENT:processor.processSymbol("/=");break;case REMAINDER_ASSIGNMENT:processor.processSymbol("%=");break;case PLUS_ASSIGNMENT:processor.processSymbol("+=");break;case MINUS_ASSIGNMENT:processor.processSymbol("-=");break;case PREFIX_INCREMENT:processor.processSymbol("++");break;case PREFIX_DECREMENT:processor.processSymbol("--");break;default:throw new IllegalArgumentException("Unrecognized operator "+kind.toString());}}public void visitParens(JCTree.JCParens jcParens){processor.processOpenParenthesis();visitTree(jcParens.getExpression());processor.processCloseParenthesis();}public void visitReturn(JCTree.JCReturn jcReturn){processor.processKeyword("return");visitTree(jcReturn.getExpression());processor.processSymbol(";");}public void visitSelect(JCTree.JCFieldAccess jcFieldAccess){visitTree(jcFieldAccess.selected);processor.processSymbol(".");processor.processName(jcFieldAccess.getIdentifier());}public void visitSwitch(JCTree.JCSwitch jcSwitch){processor.processKeyword("switch");visitTree(jcSwitch.getExpression());processor.processOpenBlock();for(JCTree.JCCase jcCase:jcSwitch.getCases()){visitCase(jcCase);}processor.processCloseBlock();}public void visitThrow(JCTree.JCThrow jcThrow){processor.processKeyword("throw");visitTree(jcThrow.getExpression());processor.processSymbol(";");}public void visitTopLevel(JCTree.JCCompilationUnit compilationUnit){processor.processKeyword("package");visitTree(compilationUnit.getPackageName());processor.processSymbol(";");for(JCTree.JCImport jcImport:compilationUnit.getImports()){visitImport(jcImport);}for(JCTree jcTree:compilationUnit.getTypeDecls()){visitTree(jcTree);}}public void visitTree(JCTree jcTree){if(jcTree==null)return;switch(jcTree.getKind()){case ASSIGNMENT:this.visitAssign((JCTree.JCAssign)jcTree);break;case ARRAY_TYPE:this.visitTypeArray((JCTree.JCArrayTypeTree)jcTree);break;case BLOCK:this.visitBlock((JCTree.JCBlock)jcTree);break;case BREAK:this.visitBreak((JCTree.JCBreak)jcTree);break;case CLASS:this.visitClassDef((JCTree.JCClassDecl)jcTree);break;case ENHANCED_FOR_LOOP:this.visitForeachLoop((JCTree.JCEnhancedForLoop)jcTree);break;case EMPTY_STATEMENT:break;case EXPRESSION_STATEMENT:this.visitExec((JCTree.JCExpressionStatement)jcTree);break;case FOR_LOOP:this.visitForLoop((JCTree.JCForLoop)jcTree);break;case IDENTIFIER:this.visitIdent((JCTree.JCIdent)jcTree);break;case IF:this.visitIf((JCTree.JCIf)jcTree);break;case INSTANCE_OF:this.visitTypeTest((JCTree.JCInstanceOf)jcTree);break;case MEMBER_SELECT:this.visitSelect((JCTree.JCFieldAccess)jcTree);break;case METHOD:this.visitMethodDef((JCTree.JCMethodDecl)jcTree);break;case METHOD_INVOCATION:this.visitApply((JCTree.JCMethodInvocation)jcTree);break;case MODIFIERS:this.visitModifiers((JCTree.JCModifiers)jcTree);break;case NEW_CLASS:this.visitNewClass((JCTree.JCNewClass)jcTree);break;case PARAMETERIZED_TYPE:this.visitTypeApply((JCTree.JCTypeApply)jcTree);break;case PARENTHESIZED:this.visitParens((JCTree.JCParens)jcTree);break;case PRIMITIVE_TYPE:this.visitTypeIdent((JCTree.JCPrimitiveTypeTree)jcTree);break;case RETURN:this.visitReturn((JCTree.JCReturn)jcTree);break;case SWITCH:this.visitSwitch((JCTree.JCSwitch)jcTree);break;case THROW:this.visitThrow((JCTree.JCThrow)jcTree);break;case TRY:this.visitTry((JCTree.JCTry)jcTree);break;case TYPE_CAST:this.visitTypeCast((JCTree.JCTypeCast)jcTree);break;case VARIABLE:this.visitVarDef((JCTree.JCVariableDecl)jcTree);break;case PLUS:case MINUS:case MULTIPLY:case DIVIDE:case REMAINDER:case LESS_THAN:case GREATER_THAN:case LESS_THAN_EQUAL:case GREATER_THAN_EQUAL:case EQUAL_TO:case NOT_EQUAL_TO:case AND:case XOR:case OR:case CONDITIONAL_AND:case CONDITIONAL_OR:case MULTIPLY_ASSIGNMENT:case DIVIDE_ASSIGNMENT:case REMAINDER_ASSIGNMENT:case PLUS_ASSIGNMENT:case MINUS_ASSIGNMENT:case LEFT_SHIFT_ASSIGNMENT:case RIGHT_SHIFT_ASSIGNMENT:case UNSIGNED_RIGHT_SHIFT_ASSIGNMENT:case AND_ASSIGNMENT:case XOR_ASSIGNMENT:case OR_ASSIGNMENT:this.visitBinary((JCTree.JCBinary)jcTree);break;case INT_LITERAL:case LONG_LITERAL:case FLOAT_LITERAL:case DOUBLE_LITERAL:case BOOLEAN_LITERAL:case CHAR_LITERAL:case STRING_LITERAL:case NULL_LITERAL:this.visitLiteral((JCTree.JCLiteral)jcTree);break;case PREFIX_INCREMENT:case PREFIX_DECREMENT:this.visitUnary((JCTree.JCUnary)jcTree);break;default:throw new IllegalArgumentException("Unhandled kind "+jcTree.getKind().toString());}}public void visitTry(JCTree.JCTry jcTry){processor.processKeyword("try");visitBlock(jcTry.getBlock());for(JCTree.JCCatch jcCatch:jcTry.getCatches()){visitCatch(jcCatch);}if(jcTry.getFinallyBlock()!=null){processor.processKeyword("finally");visitBlock(jcTry.getFinallyBlock());}}public void visitTypeApply(JCTree.JCTypeApply jcTypeApply){visitTree(jcTypeApply.getType());processor.processSymbol("<");List<JCTree.JCExpression>typeArguments=jcTypeApply.getTypeArguments();visitTree(typeArguments.get(0));for(JCTree.JCExpression jcExpression:typeArguments.subList(1,typeArguments.size())){processor.processSymbol(",");visitTree(jcExpression);}processor.processSymbol(">");}public void visitTypeArray(JCTree.JCArrayTypeTree jcArrayTypeTree){visitTree(jcArrayTypeTree.getType());processor.processSymbol("[]");}public void visitTypeCast(JCTree.JCTypeCast jcTypeCast){processor.processOpenParenthesis();visitTree(jcTypeCast.getType());processor.processCloseParenthesis();visitTree(jcTypeCast.getExpression());}public void visitTypeIdent(JCTree.JCPrimitiveTypeTree jcPrimitiveTypeTree){processor.processKeyword(jcPrimitiveTypeTree.getPrimitiveTypeKind().toString().toLowerCase());}public void visitTypeTest(JCTree.JCInstanceOf jcInstanceOf){visitTree(jcInstanceOf.getExpression());processor.processKeyword("instanceof");visitTree(jcInstanceOf.getType());}public void visitUnary(JCTree.JCUnary jcUnary){visitOperator(jcUnary.getKind());visitTree(jcUnary.getExpression());}public void visitVarDef(JCTree.JCVariableDecl jcVariableDecl){visitModifiers(jcVariableDecl.getModifiers());visitTree(jcVariableDecl.vartype);processor.processName(jcVariableDecl.getName());if(jcVariableDecl.getInitializer()!=null){processor.processSymbol("=");visitTree(jcVariableDecl.getInitializer());processor.processSymbol(";");}}}


    // Autogenerated code:
    public static class Processor extends JCTree.Visitor
    {
        private int indentLevel = 0;
        private List<String> nestedClasses = new ArrayList<String>();

        private String getCurrentClass()
        {

            return nestedClasses.get(nestedClasses.size() - 1);
        }

        private void print(Object toPrint)
        {
            StringBuilder indentBuilder = new StringBuilder();
            for (int i = 0; i < indentLevel; ++i) indentBuilder.append("\t");
            System.out.print(toPrint.toString().replaceAll("\n", "\n" + indentBuilder.toString()));
        }

        public void visitApply(JCTree.JCMethodInvocation jcMethodInvocation)
        {
            visitTree(jcMethodInvocation.getMethodSelect());
            print("(");
            List<JCTree.JCExpression> arguments = jcMethodInvocation.getArguments();
            if (arguments.size() > 0)
            {
                visitTree(arguments.get(0));
                for (JCTree.JCExpression arg : arguments.subList(1, arguments.size()))
                {
                    print(", ");
                    visitTree(arg);
                }
            }
            print(")");
        }

        public void visitAssign(JCTree.JCAssign jcAssign)
        {
            visitTree(jcAssign.getVariable());
            print(" = ");
            visitTree(jcAssign.getExpression());
            print(";");
        }

        public void visitBinary(JCTree.JCBinary jcBinary)
        {
            visitTree(jcBinary.getLeftOperand());
            print(" ");
            visitOperator(jcBinary.getKind());
            print(" ");
            visitTree(jcBinary.getRightOperand());
        }

        public void visitBlock(JCTree.JCBlock jcBlock)
        {
            print("\n{");
            ++indentLevel;
            for (JCTree.JCStatement jcStatement : jcBlock.getStatements())
            {
                print("\n");
                visitTree(jcStatement);
            }
            --indentLevel;
            print("\n}");
        }

        public void visitBreak(JCTree.JCBreak jcBreak)
        {
            print("break;");
        }

        public void visitCase(JCTree.JCCase jcCase)
        {
            print("\n");
            if (jcCase.getExpression() == null)
            {
                print("default");
            }
            else
            {
                print("case ");
                visitTree(jcCase.getExpression());
            }
            print(":");
            ++indentLevel;
            for (JCTree.JCStatement statement : jcCase.getStatements())
            {
                print("\n");
                visitTree(statement);
            }
            --indentLevel;
        }

        public void visitCatch(JCTree.JCCatch jcCatch)
        {
            print("\ncatch (");
            visitVarDef(jcCatch.getParameter());
            print(")");
            visitBlock(jcCatch.getBlock());
        }

        public void visitClassDef(JCTree.JCClassDecl jcClassDecl)
        {
            print("\n\n");
            visitModifiers(jcClassDecl.getModifiers());
            print("class " + jcClassDecl.getSimpleName());
            if (jcClassDecl.getExtendsClause() != null)
            {
                print(" extends ");
                visitTree(jcClassDecl.getExtendsClause());
            }
            List<JCTree.JCExpression> interfaces = jcClassDecl.getImplementsClause();
            if (interfaces.size() > 0)
            {
                print(" implements ");
                visitTree(interfaces.get(0));
                for (JCTree.JCExpression jcExpression : interfaces.subList(1, interfaces.size()))
                {
                    print(", ");
                    visitTree(jcExpression);
                }
            }
            nestedClasses.add(jcClassDecl.getSimpleName().toString());
            visitClassMembers(jcClassDecl.getMembers());
            nestedClasses.remove(nestedClasses.size() - 1);
        }

        private void visitClassMembers(List<JCTree> members)
        {
            print("\n{");
            ++indentLevel;
            for (JCTree member : members)
            {
                print("\n");
                visitTree(member);
            }
            --indentLevel;
            print("\n}\n");
        }

        public void visitExec(JCTree.JCExpressionStatement jcExpressionStatement)
        {
            visitTree(jcExpressionStatement.getExpression());
            print(";");
        }

        public void visitForeachLoop(JCTree.JCEnhancedForLoop jcEnhancedForLoop)
        {
            print("for (");
            visitVarDef(jcEnhancedForLoop.getVariable());
            print(" : ");
            visitTree(jcEnhancedForLoop.getExpression());
            print(") ");
            visitTree(jcEnhancedForLoop.getStatement());
        }

        public void visitForLoop(JCTree.JCForLoop jcForLoop)
        {
            print("for (");
            List<JCTree.JCStatement> initializers = jcForLoop.getInitializer();
            if (initializers.size() == 1)
            {
                visitTree(initializers.get(0));
            }
            else if (initializers.size() > 1) throw new IllegalArgumentException("Too many initializers: " + initializers.size());
            print(" ");
            visitTree(jcForLoop.getCondition());
            print("; ");
            List<JCTree.JCExpressionStatement> updates = jcForLoop.getUpdate();
            if (updates.size() == 1)
            {
                visitTree(updates.get(0).getExpression());
            }
            else if (initializers.size() > 1) throw new IllegalArgumentException("Too many initializers: " + initializers.size());
            print(") ");
            visitTree(jcForLoop.getStatement());
        }

        public void visitIdent(JCTree.JCIdent jcIdent)
        {
            print(jcIdent.getName());
        }

        public void visitIf(JCTree.JCIf jcIf)
        {
            print("if ");
            visitTree(jcIf.getCondition());
            print(" ");
            visitTree(jcIf.getThenStatement());
            if (jcIf.getElseStatement() != null)
            {
                print("\nelse ");
                visitTree(jcIf.getElseStatement());
            }
        }

        public void visitImport(JCTree.JCImport jcImport)
        {
            print("\n");
            if (jcImport.isStatic()) System.out.print("static ");
            print("import ");
            visitTree(jcImport.getQualifiedIdentifier());
            print(";");
        }

        public void visitLiteral(JCTree.JCLiteral jcLiteral)
        {
            print(jcLiteral.toString());
        }

        public void visitMethodDef(JCTree.JCMethodDecl jcMethodDecl)
        {
            print("\n");
            visitModifiers(jcMethodDecl.getModifiers());
            if (jcMethodDecl.getReturnType() != null)
            {
                visitTree(jcMethodDecl.getReturnType());
                print(" ");
            }
            if (jcMethodDecl.getName().toString().equals("<init>")) print(getCurrentClass());
            else print(jcMethodDecl.getName());
            print("(");
            List<JCTree.JCVariableDecl> parameters = jcMethodDecl.getParameters();
            if (parameters.size() > 0)
            {
                visitVarDef(parameters.get(0));
                for (JCTree.JCVariableDecl param : parameters.subList(1, parameters.size()))
                {
                    print(", ");
                    visitVarDef(param);
                }
            }
            print(")");
            List<JCTree.JCExpression> possibleExceptions = jcMethodDecl.getThrows();
            if (possibleExceptions.size() > 0)
            {
                print(" throws ");
                visitTree(possibleExceptions.get(0));
                for (JCTree.JCExpression exception : possibleExceptions.subList(1, possibleExceptions.size()))
                {
                    print(", ");
                    visitTree(exception);
                }
            }
            visitBlock(jcMethodDecl.getBody());
        }

        public void visitModifiers(JCTree.JCModifiers jcModifiers)
        {
            for (Modifier modifier : jcModifiers.getFlags())
            {
                print(modifier.toString() + " ");
            }
        }

        public void visitNewClass(JCTree.JCNewClass jcNewClass)
        {
            print("new " + jcNewClass.getIdentifier() + "(");
            List<JCTree.JCExpression> arguments = jcNewClass.getArguments();
            if (arguments.size() > 0)
            {
                visitTree(arguments.get(0));
                for (JCTree.JCExpression arg : arguments.subList(1, arguments.size()))
                {
                    print(", ");
                    visitTree(arg);
                }
            }
            print(")");
            if (jcNewClass.getClassBody() != null)
            {
                visitClassMembers(jcNewClass.getClassBody().getMembers());
            }
        }

        private void visitOperator(Tree.Kind kind)
        {
            switch (kind)
            {
                case PLUS:
                    print("+");
                    break;
                case MINUS:
                    print("-");
                    break;
                case MULTIPLY:
                    print("*");
                    break;
                case DIVIDE:
                    print("/");
                    break;
                case REMAINDER:
                    print("%");
                    break;
                case LESS_THAN:
                    print("<");
                    break;
                case GREATER_THAN:
                    print(">");
                    break;
                case LESS_THAN_EQUAL:
                    print("<=");
                    break;
                case GREATER_THAN_EQUAL:
                    print(">=");
                    break;
                case EQUAL_TO:
                    print("==");
                    break;
                case NOT_EQUAL_TO:
                    print("!=");
                    break;
                case AND:
                    print("&&");
                    break;
                case OR:
                    print("||");
                    break;
                case MULTIPLY_ASSIGNMENT:
                    print("*=");
                    break;
                case DIVIDE_ASSIGNMENT:
                    print("/=");
                    break;
                case REMAINDER_ASSIGNMENT:
                    print("%=");
                    break;
                case PLUS_ASSIGNMENT:
                    print("+=");
                    break;
                case MINUS_ASSIGNMENT:
                    print("-=");
                    break;
                case PREFIX_INCREMENT:
                    print("++");
                    break;
                case PREFIX_DECREMENT:
                    print("--");
                    break;
                default:
                    throw new IllegalArgumentException("Unrecognized operator " + kind.toString());
            }
        }

        public void visitParens(JCTree.JCParens jcParens)
        {
            print("(");
            visitTree(jcParens.getExpression());
            print(")");
        }

        public void visitReturn(JCTree.JCReturn jcReturn)
        {
            print("\nreturn ");
            visitTree(jcReturn.getExpression());
            print(";");
        }

        public void visitSelect(JCTree.JCFieldAccess jcFieldAccess)
        {
            visitTree(jcFieldAccess.selected);
            print("." + jcFieldAccess.getIdentifier());
        }

        public void visitSwitch(JCTree.JCSwitch jcSwitch)
        {
            print("switch ");
            visitTree(jcSwitch.getExpression());
            print("\n{");
            ++indentLevel;
            for (JCTree.JCCase jcCase : jcSwitch.getCases())
            {
                visitCase(jcCase);
            }
            --indentLevel;
            print("\n}");
        }

        public void visitThrow(JCTree.JCThrow jcThrow)
        {
            print("throw ");
            visitTree(jcThrow.getExpression());
            print(";");
        }

        public void visitTopLevel(JCTree.JCCompilationUnit compilationUnit)
        {
            print("package " + compilationUnit.getPackageName() + ";\n");
            for (JCTree.JCImport jcImport : compilationUnit.getImports())
            {
                visitImport(jcImport);
            }
            for (JCTree jcTree : compilationUnit.getTypeDecls())
            {
                visitTree(jcTree);
            }
        }

        public void visitTree(JCTree jcTree)
        {
            if (jcTree == null)
                return ;
            switch (jcTree.getKind())
            {
                case ASSIGNMENT:
                    this.visitAssign((JCTree.JCAssign) jcTree);
                    break;
                case ARRAY_TYPE:
                    this.visitTypeArray((JCTree.JCArrayTypeTree) jcTree);
                    break;
                case BLOCK:
                    this.visitBlock((JCTree.JCBlock) jcTree);
                    break;
                case BREAK:
                    this.visitBreak((JCTree.JCBreak) jcTree);
                    break;
                case CLASS:
                    this.visitClassDef((JCTree.JCClassDecl) jcTree);
                    break;
                case ENHANCED_FOR_LOOP:
                    this.visitForeachLoop((JCTree.JCEnhancedForLoop) jcTree);
                    break;
                case EMPTY_STATEMENT:
                    break;
                case EXPRESSION_STATEMENT:
                    this.visitExec((JCTree.JCExpressionStatement) jcTree);
                    break;
                case FOR_LOOP:
                    this.visitForLoop((JCTree.JCForLoop) jcTree);
                    break;
                case IDENTIFIER:
                    this.visitIdent((JCTree.JCIdent) jcTree);
                    break;
                case IF:
                    this.visitIf((JCTree.JCIf) jcTree);
                    break;
                case INSTANCE_OF:
                    this.visitTypeTest((JCTree.JCInstanceOf) jcTree);
                    break;
                case MEMBER_SELECT:
                    this.visitSelect((JCTree.JCFieldAccess) jcTree);
                    break;
                case METHOD:
                    this.visitMethodDef((JCTree.JCMethodDecl) jcTree);
                    break;
                case METHOD_INVOCATION:
                    this.visitApply((JCTree.JCMethodInvocation) jcTree);
                    break;
                case MODIFIERS:
                    this.visitModifiers((JCTree.JCModifiers) jcTree);
                    break;
                case NEW_CLASS:
                    this.visitNewClass((JCTree.JCNewClass) jcTree);
                    break;
                case PARAMETERIZED_TYPE:
                    this.visitTypeApply((JCTree.JCTypeApply) jcTree);
                    break;
                case PARENTHESIZED:
                    this.visitParens((JCTree.JCParens) jcTree);
                    break;
                case PRIMITIVE_TYPE:
                    print(jcTree.toString());
                    break;
                case RETURN:
                    this.visitReturn((JCTree.JCReturn) jcTree);
                    break;
                case SWITCH:
                    this.visitSwitch((JCTree.JCSwitch) jcTree);
                    break;
                case THROW:
                    this.visitThrow((JCTree.JCThrow) jcTree);
                    break;
                case TRY:
                    this.visitTry((JCTree.JCTry) jcTree);
                    break;
                case TYPE_CAST:
                    this.visitTypeCast((JCTree.JCTypeCast) jcTree);
                    break;
                case VARIABLE:
                    this.visitVarDef((JCTree.JCVariableDecl) jcTree);
                    break;
                case PLUS:
                case MINUS:
                case MULTIPLY:
                case DIVIDE:
                case REMAINDER:
                case LESS_THAN:
                case GREATER_THAN:
                case LESS_THAN_EQUAL:
                case GREATER_THAN_EQUAL:
                case EQUAL_TO:
                case NOT_EQUAL_TO:
                case AND:
                case XOR:
                case OR:
                case CONDITIONAL_AND:
                case CONDITIONAL_OR:
                case MULTIPLY_ASSIGNMENT:
                case DIVIDE_ASSIGNMENT:
                case REMAINDER_ASSIGNMENT:
                case PLUS_ASSIGNMENT:
                case MINUS_ASSIGNMENT:
                case LEFT_SHIFT_ASSIGNMENT:
                case RIGHT_SHIFT_ASSIGNMENT:
                case UNSIGNED_RIGHT_SHIFT_ASSIGNMENT:
                case AND_ASSIGNMENT:
                case XOR_ASSIGNMENT:
                case OR_ASSIGNMENT:
                    this.visitBinary((JCTree.JCBinary) jcTree);
                    break;
                case INT_LITERAL:
                case LONG_LITERAL:
                case FLOAT_LITERAL:
                case DOUBLE_LITERAL:
                case BOOLEAN_LITERAL:
                case CHAR_LITERAL:
                case STRING_LITERAL:
                case NULL_LITERAL:
                    this.visitLiteral((JCTree.JCLiteral) jcTree);
                    break;
                case PREFIX_INCREMENT:
                case PREFIX_DECREMENT:
                    this.visitUnary((JCTree.JCUnary) jcTree);
                    break;
                default:
                    throw new IllegalArgumentException("Unhandled kind " + jcTree.getKind().toString());
            }
        }

        public void visitTry(JCTree.JCTry jcTry)
        {
            print("\ntry");
            visitBlock(jcTry.getBlock());
            for (JCTree.JCCatch jcCatch : jcTry.getCatches())
            {
                visitCatch(jcCatch);
            }
            if (jcTry.getFinallyBlock() != null)
            {
                print("\nfinally");
                visitBlock(jcTry.getFinallyBlock());
            }
        }

        public void visitTypeApply(JCTree.JCTypeApply jcTypeApply)
        {
            visitTree(jcTypeApply.getType());
            print("<");
            List<JCTree.JCExpression> typeArguments = jcTypeApply.getTypeArguments();
            visitTree(typeArguments.get(0));
            for (JCTree.JCExpression jcExpression : typeArguments.subList(1, typeArguments.size()))
            {
                print(", ");
                visitTree(jcExpression);
            }
            print(">");
        }

        public void visitTypeArray(JCTree.JCArrayTypeTree jcArrayTypeTree)
        {
            visitTree(jcArrayTypeTree.getType());
            print("[]");
        }

        public void visitTypeCast(JCTree.JCTypeCast jcTypeCast)
        {
            print("(");
            visitTree(jcTypeCast.getType());
            print(") ");
            visitTree(jcTypeCast.getExpression());
        }

        public void visitTypeTest(JCTree.JCInstanceOf jcInstanceOf)
        {
            visitTree(jcInstanceOf.getExpression());
            print(" instanceof ");
            visitTree(jcInstanceOf.getType());
        }

        public void visitUnary(JCTree.JCUnary jcUnary)
        {
            visitOperator(jcUnary.getKind());
            visitTree(jcUnary.getExpression());
        }

        public void visitVarDef(JCTree.JCVariableDecl jcVariableDecl)
        {
            visitModifiers(jcVariableDecl.getModifiers());
            visitTree(jcVariableDecl.vartype);
            print(" " + jcVariableDecl.getName());
            if (jcVariableDecl.getInitializer() != null)
            {
                print(" = ");
                visitTree(jcVariableDecl.getInitializer());
                print(";");
            }
        }
    }
}
